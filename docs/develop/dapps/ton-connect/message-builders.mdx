# Preparing Messages

While using TON Connect you should build Message Body for Payload for various transactions. Here you can find most relatable examples for payload for using it in TON Connect SDKs.

:::warning
The page is under development.
:::


## Regular TON Transfer Example
TON Connect SDKs include wrappers for sending messages, making it easy to prepare regular transfers of Toncoins between two wallets. For example, a regular TON transfer using the TON Connect JS SDK can be executed as follows:

if (!connector.connected) {
    alert('Please connect wallet to send the transaction!');
}

```ts
if (!connector.connected) {
    alert('Please connect wallet to send the transaction!');
}

const transaction = {
    messages: [
        {
            address: "0:412410771DA82CBA306A55FA9E0D43C9D245E38133CB58F1457DFB8D5CD8892F", // destination address
            amount: "20000000" //Toncoin in nanotons
        }
    ]
}
```

For other custom tasks, a specific payload should be specified.


## TON Connect JS SDK Examples

### Transfer with comment

```js
const body = beginCell()
  .storeUint(0, 32) // write 32 zero bits to indicate that a text comment will follow
  .storeStringTail("Hello, TON!") // write our text comment
  .endCell();


await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: jettonWalletContract,
      amount: toNano("0.05"),
      payload: body.toBoc().toString("base64")
    }
  ]
})
```

### Jettons (Tokens) transaction

#### Mint Jetton

```js
let body = beginCell()
     //Mint message body
    .endCell()


await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: jettonWalletContract,
      amount: toNano("0.05"),
      payload: body.toBoc().toString("base64")
    }
  ]
})
```

- `jettonWalletAddress` - Address, JettonWallet address, that defined based on JettonMaser and Wallet contracts
- `balance` - Integer, amount of Toncoin for gas payments in nanotons.
- `body` - payload for the jettonContract, which defines what should be done
        -  `$$type`: string, "Mint" string (or corresponded op-code for Mint)
        -  `amount`: bigint, amount of Jettons should be minted


#### Jetton Transfer

The `body` for Jetton Transfer([TEP-74](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#1-transfer)) typically should be done according the following way:

```js
    import {beginCell, toNano} from '@ton/ton'
    // transfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
    // response_destination:MsgAddress custom_payload:(Maybe ^Cell)
    // forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
    // = InternalMsgBody;

    const body = beginCell()
        .storeUint(0xf8a7ea5, 32)                 // jetton transfer op code
        .storeUint(0, 64)                         // query_id:uint64
        .storeCoins(1000000)                      // amount:(VarUInteger 16) -  Jetton amount for transfer (6 - jUSDT, 9 - default)
        .storeAddress(Wallet_DST)                 // destination:MsgAddress
        .storeAddress(Wallet_SRC)                 // response_destination:MsgAddress
        .storeUint(0, 1)                          // custom_payload:(Maybe ^Cell)
        .storeCoins(toNano(0.05))                 // forward_ton_amount:(VarUInteger 16)
        .storeUInt(0,1)                           // forward_payload:(Either Cell ^Cell)
        .endCell();
```

Next, sending the transaction with this body to jettonWalletContract destination executed:

```js
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: jettonWalletContract,            // dst jetton wallet
      amount: toNano("0.05"),                   // for commission fees, excess will be returned
      payload: body.toBoc().toString("base64")
    }
  ]
})
```

- `jettonWalletAddress` - Address, JettonWallet address, that defined based on JettonMaser and Wallet contracts
- `balance` - Integer, amount of Toncoin for gas payments in nanotons.
- `body` - payload for the jettonContract


<details>
    <summary>Jetton Wallet State Init and Address preparation example</summary>


```js
import { Address, TonClient, beginCell, StateInit, storeStateInit } from '@ton/ton'

async function main() {
    const client = new TonClient({
        endpoint: 'https://toncenter.com/api/v2/jsonRPC',
        apiKey: 'put your api key'
    })

    const jettonWalletAddress = Address.parse('Sender_Jetton_Wallet');
    let jettonWalletDataResult = await client.runMethod(jettonWalletAddress, 'get_wallet_data');
    jettonWalletDataResult.stack.readNumber();
    const ownerAddress = jettonWalletDataResult.stack.readAddress();
    const jettonMasterAddress = jettonWalletDataResult.stack.readAddress();
    const jettonCode = jettonWalletDataResult.stack.readCell();
    const jettonData = beginCell()
        .storeCoins(0)
        .storeAddress(ownerAddress)
        .storeAddress(jettonMasterAddress)
        .storeRef(jettonCode)
        .endCell();

    const stateInit: StateInit = {
        code: jettonCode,
        data: jettonData
    }

    const stateInitCell = beginCell()
        .store(storeStateInit(stateInit))
        .endCell();

    console.log(new Address(0, stateInitCell.hash()));
}
```

</details>

#### Jetton Burn

The `body` for Jetton Burn([TEP-74](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#2-burn)) typically should be done according the following way:


```js
    import {beginCell, toNano} from '@ton/ton'
// burn#595f07bc query_id:uint64 amount:(VarUInteger 16)
//               response_destination:MsgAddress custom_payload:(Maybe ^Cell)
//               = InternalMsgBody;

    const body = beginCell()
        .storeUint(0x595f07bc, 32)                // jetton burn op code
        .storeUint(0, 64)                         // query_id:uint64
        .storeCoins(1000000)                      // amount:(VarUInteger 16) -  Jetton amount in decimal
        .storeAddress(Wallet_SRC)                 // response_destination:MsgAddress - owner's wallet
        .storeUint(0, 1)                          // custom_payload:(Maybe ^Cell) - w/o payload typically
        .endCell();
```


```js
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: jettonWalletContract,
      amount: toNano("0.05"),
      payload: body.toBoc().toString("base64")
    }
  ]
})
```

- `jettonWalletAddress` - Address, jettonWalletContract - which desire to burn his jettons
- `amount` - Integer, amount of Toncoin for gas payments in nanotons.
- `body` - payload for the jetton wallet with the `burn#595f07bc` op code

### NFTs

#### Transfer NFT

Transfer the `NFTitem` to a new owner `NEW_OWNER_WALLET`.

```js
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: NFTitem,
      amount: toNano("0.05"),
      payload: body.toBoc().toString("base64")
    }
  ]
})
```

- `NFTitem` - Address - The address of NFT item smart contract which we want transfer to a new owner `NEW_OWNER_WALLET`.
- `balance` - Integer, amount of Toncoin for gas payments in nanotons.
- `body` - payload for the NFT contract

`body` typically should be done according the following way:

```js
import { beginCell, toNano} from '@ton/ton'

//  transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell)
//   forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;

    const body = beginCell()
        .storeUint(0x5fcc3d14, 32)               // NFT transfer op code 0x5fcc3d14
        .storeUint(0, 64)                        // query_id:uint64
        .storeAddress(NEW_OWNER_WALLET)          // new_owner:MsgAddress
        .storeAddress(Wallet_DST)                // response_destination:MsgAddress
        .storeUint(0, 1)                         // custom_payload:(Maybe ^Cell)
        .storeCoins(toNano('0.000000001'))       // forward_amount:(VarUInteger 16)
        .storeUint(0,1)                          // forward_payload:(Either Cell ^Cell)
        .endCell();
```

`WALLET_DST` - Address - The address of the initial NFT owner for the receiving excess


#### NFT Sale Example
Here example of preparing message and transaction for sale on GetGems markteplace, according to contract [nft-fixprice-sale-v3r2](https://github.com/getgems-io/nft-contracts/blob/main/packages/contracts/sources/nft-fixprice-sale-v3r2.fc).


```js
import { Address, beginCell, StateInit, storeStateInit, toNano, Cell } from '@ton/ton'

async function main() {
const fixPriceV3R2Code = Cell.fromBase64('te6cckECCwEAArkAART/APSkE/S88sgLAQIBIAIDAgFIBAUAfvIw7UTQ0wDTH/pA+kD6QPoA1NMAMMABjh34AHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVOBfB4IA//7y8AICzQYHAFegOFnaiaGmAaY/9IH0gfSB9AGppgBgYaH0gfQB9IH0AGEEIIySsKAVgAKrAQH30A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppgBgYOCmE44BgAEqYhOmPhW8Q4YBKGATpn8cIxbMbC3MbK2QV44LJOZlvKAVxFWAAyS+G8BJrpOEBFcCBFd0VYACRWdjYKdxjgthOjq+G6hhoaYPqGAD9gHAU4ADAgB92YIQO5rKAFJgoFIwvvLhwiTQ+kD6APpA+gAwU5KhIaFQh6EWoFKQcIAQyMsFUAPPFgH6AstqyXH7ACXCACXXScICsI4XUEVwgBDIywVQA88WAfoCy2rJcfsAECOSNDTiWnCAEMjLBVADzxYB+gLLaslx+wBwIIIQX8w9FIKAejy0ZSzjkIxMzk5U1LHBZJfCeBRUccF8uH0ghAFE42RFrry4fUD+kAwRlAQNFlwB8jLABbLH1AEzxZYzxYBzxYB+gLMywDJ7VTgMDcowAPjAijAAJw2NxA4R2UUQzBw8AXgCMACmFVEECQQI/AF4F8KhA/y8AkA1Dg5ghA7msoAGL7y4clTRscFUVLHBRWx8uHKcCCCEF/MPRQhgBDIywUozxYh+gLLassfFcs/J88WJ88WFMoAI/oCE8oAyYMG+wBxUGZFFQRwB8jLABbLH1AEzxZYzxYBzxYB+gLMywDJ7VQAlsjLHxPLPyPPFlADzxbKAIIJycOA+gLKAMlxgBjIywUmzxZw+gLLaszJgwb7AHFVUHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVNZeZYk=');
// GetGems Address
const marketplaceAddress = Address.parse('EQBYTuYbLf8INxFtD8tQeNk5ZLy-nAX9ahQbG_yl1qQ-GEMS');
// GetGems Address for Fees
const marketplaceFeeAddress = Address.parse('EQCjk1hh952vWaE9bRguFkAhDAL5jj3xj9p0uPWrFBq_GEMS');
// GetGems sale contracts deployer
const destinationAddress = Address.parse("EQAIFunALREOeQ99syMbO6sSzM_Fa1RsPD5TBoS0qVeKQ-AR");

    const walletAddress = Address.parse('EQArLGBnGPvkxaJE57Y6oS4rwzDWuOE8l8_sghntXLkIt162');
    const royaltyAddress = Address.parse('EQArLGBnGPvkxaJE57Y6oS4rwzDWuOE8l8_sghntXLkIt162');
    const nftAddress = Address.parse('EQCUWoe7hLlklVxH8gduCf45vPNocsjRP4wbX42UJ0Ja0S2f');
    const price = toNano('5'); // 5 TON

    const feesData = beginCell()
        .storeAddress(marketplaceFeeAddress)
        // 5% - GetGems fee
        .storeCoins(price / BigInt(100) * BigInt(5))
        .storeAddress(royaltyAddress)
        // 5% - Royalty, can be changed
        .storeCoins(price / BigInt(100) * BigInt(5))
        .endCell();

    const saleData = beginCell()
        .storeBit(0) // is_complete
        .storeUint(Math.round(Date.now() / 1000), 32) // created_at
        .storeAddress(marketplaceAddress) // marketplace_address
        .storeAddress(nftAddress) // nft_address
        .storeAddress(walletAddress) // previous_owner_address
        .storeCoins(price) // full_price
        .storeRef(feesData) // fees_cell
        .storeBit(0) // can_be_deployed_externally
        .endCell();

    const stateInit: StateInit = {
        code: fixPriceV3R2Code,
        data: saleData
    };
    const stateInitCell = beginCell()
        .store(storeStateInit(stateInit))
        .endCell();

    // not needed, just for example
    const saleContractAddress = new Address(0, stateInitCell.hash());

    const saleBody = beginCell()
        .storeUint(1, 32) // just accept coins on deploy
        .storeUint(0, 64)
        .endCell();

    const transferNftBody = beginCell().
        storeUint(0x5fcc3d14, 32). // Opcode for NFT transfer
        storeUint(0, 64). // query_id
        storeAddress(destinationAddress). // new_owner
        storeAddress(walletAddress). // response_destination for excesses
        storeBit(0). // we do not have custom_payload
        storeCoins(toNano("1")). // forward_amount
        storeBit(0). // we store forward_payload is this cell
        // not 32, because we stored 0 bit before | do_sale opcode for deployer
        storeUint(0x0fe0ede, 31).
        storeRef(stateInitCell).
        storeRef(saleBody).
        endCell();
```



```js
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: nftItemAddress,
      amount: toNano("1.08"),
      payload: body.toBoc().toString("base64")
    }
  ]
})
```