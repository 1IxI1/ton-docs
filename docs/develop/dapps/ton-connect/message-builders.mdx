# Preparing Messages

While using TON Connect you should build Message Body for Payload for various transactions. Here you can find most relatable examples for payload for using it in TON Connect SDKs.

:::warning
Page in development.
:::


## Regular TON Transfer
As ton-connect SDK is already wrapper above messages, we have no problem to prepare regular Transfer. For the following actions we should specify Payload(Message Body)


## TON Connect React UI

### Jettons

Suppose, we specified simple hook built with ton-connect/react-ui useJettonContract.ts, which defines mint request from our application:

<details>
<summary>Open entire script</summary>

```ts
import { useEffect, useState } from "react";
import { Address, fromNano, OpenedContract, toNano } from "ton-core";
import {Mint, SampleJetton} from "../../build/SampleJetton/tact_SampleJetton";
import {JettonDefaultWallet} from "../../build/SampleJetton/tact_JettonDefaultWallet";
import { useAsyncInitialize } from "./useAsyncInitialize";
import { useTonClient } from "./useTonClient";
import { useTonConnect } from "./useTonConnect";

const sleep = (time: number) => new Promise((resolve) => setTimeout(resolve, time))

export function useJettonContract() {
    const {client} = useTonClient()
    const {wallet, sender} = useTonConnect()
    const [balance, setBalance] = useState<string | null>()

    const jettonContract = useAsyncInitialize(async()=>{
        if(!client || !wallet) return;

        const contract = SampleJetton.fromAddress(Address.parse("EQB8StgTQXidy32a8xfu7j4HMoWYV0b0cFM8nXsP2cza_b7Y"))

        return client.open(contract) as OpenedContract<SampleJetton>
    }, [client, wallet])

    const jettonWalletContract = useAsyncInitialize(async()=>{
        if(!jettonContract || !client) return;

        const jettonWalletAddress = await jettonContract.getGetWalletAddress(
            Address.parse(Address.parse(wallet!).toString())
        )

        return client.open(JettonDefaultWallet.fromAddress(jettonWalletAddress))
    }, [jettonContract, client])

    useEffect(()=>{
        async function getBalance() {
            if(!jettonWalletContract) return
            setBalance(null)
            const balance = (await jettonWalletContract.getGetWalletData()).balance
            setBalance(fromNano(balance))
            await sleep(5000)
            getBalance()
        }

        getBalance()

    }, [jettonWalletContract])

    return {
        jettonWalletAddress: jettonWalletContract?.address.toString(),
        balance: balance,
        mint: () => {
            const message: Mint = {
                $$type: "Mint",
                amount: 150n
            }

            jettonContract?.send(sender, {
                value: toNano("0.05")
            }, message)
        }
    }
}
```

</details>

```ts
/// previous part
 return {
        jettonWalletAddress: jettonWalletContract?.address.toString(),
        balance: balance,
        mint: () => {
            const message: Mint = {
                $$type: "Mint",
                amount: 150n
            }

            jettonContract?.send(sender, {
                value: toNano("0.05")
            }, message)
        }
    }
```

Here our payload defined by sending `send()` message with following specs:

- `jettonWalletAddress` - Address, JettonWallet address, that defined based on JettonMaser and Wallet contracts
- `balance` - Integer, amount of Toncoin for gas payments in nanotons.
- `mint` - function, which invokes internal transfer from jettonContract(jetton master) to sender's Jetton Wallet
    - `sender` - wallet address, which requested mint and which will receive jettons on his Jetton Wallet
    - `value` - amount of Toncoins carried for gas payments between Jetton Master and new Jetton Wallet
    - `message` - payload for the jettonContract, which defines what should be done
        -  `$$type`: string, "Mint" string (or corresponded op-code for Mint)
        -  `amount`: bigint, amount of Jettons should be minted



```ts "title" = "destination address"


```


#### Jetton Transfer



## TON Connect JS SDK

#### Mint Jetton

```js
let body = beginCell()
     //Mint message body
    .endCell()


await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: jettonWalletContract,
      amount: toNano("0.05"),
      payload: body.toBoc().toString("base64")
    }
  ]
})
```

- `jettonWalletAddress` - Address, JettonWallet address, that defined based on JettonMaser and Wallet contracts
- `balance` - Integer, amount of Toncoin for gas payments in nanotons.
- `body` - payload for the jettonContract, which defines what should be done
        -  `$$type`: string, "Mint" string (or corresponded op-code for Mint)
        -  `amount`: bigint, amount of Jettons should be minted


#### Jetton Transfer

```js
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: jettonWalletContract,
      amount: toNano("0.05"),
      payload: body.toBoc().toString("base64")
    }
  ]
})
```

- `jettonWalletAddress` - Address, JettonWallet address, that defined based on JettonMaser and Wallet contracts
- `balance` - Integer, amount of Toncoin for gas payments in nanotons.
- `body` - payload for the jettonContract

`body` typically should be done according the following way:

```js
    import { Address, beginCell, Cell, toNano} from '@ton/ton'
    // transfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
    // response_destination:MsgAddress custom_payload:(Maybe ^Cell)
    // forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
    // = InternalMsgBody;

    const body = beginCell()
        .storeUint(0xf8a7ea5, 32)                 // jetton transfer op code
        .storeUint(0, 64)                         // query_id:uint64
        .storeCoins(1000000)                      // amount:(VarUInteger 16) - 6 decimals for jUSDT, 9 decimals as default
        .storeAddress(Wallet_DST)                 // destination:MsgAddress
        .storeAddress(Wallet_SRC)                 // response_destination:MsgAddress
        .storeUint(0, 1)                          // custom_payload:(Maybe ^Cell)
        .storeCoins(toNano(0.05))                 // forward_ton_amount:(VarUInteger 16)
        .endCell();                               // forward_payload:(Either Cell ^Cell)
```

```js
import { Address, TonClient, beginCell, StateInit, storeStateInit } from '@ton/ton'

async function main() {
    const client = new TonClient({
        endpoint: 'https://toncenter.com/api/v2/jsonRPC',
        apiKey: 'put your api key'
    })

    const jettonWalletAddress = Address.parse('EQBXvufa5Q9HO5O8W1J5QxfDHeSryUY6zQjOI7NDt_Zr7LCV');
    let jettonWalletDataResult = await client.runMethod(jettonWalletAddress, 'get_wallet_data');
    jettonWalletDataResult.stack.readNumber();
    const ownerAddress = jettonWalletDataResult.stack.readAddress();
    const jettonMasterAddress = jettonWalletDataResult.stack.readAddress();
    const jettonCode = jettonWalletDataResult.stack.readCell();
    const jettonData = beginCell()
        .storeCoins(0)
        .storeAddress(ownerAddress)
        .storeAddress(jettonMasterAddress)
        .storeRef(jettonCode)
        .endCell();

    const stateInit: StateInit = {
        code: jettonCode,
        data: jettonData
    }

    const stateInitCell = beginCell()
        .store(storeStateInit(stateInit))
        .endCell();

    console.log(new Address(0, stateInitCell.hash()));
}
```


#### Jetton Burn


```js
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: jettonWalletContract,
      amount: toNano("0.05"),
      payload: body.toBoc().toString("base64")
    }
  ]
})
```

- `jettonWalletAddress` - Address, JettonWallet address, that defined based on JettonMaser and Wallet contracts
- `balance` - Integer, amount of Toncoin for gas payments in nanotons.
- `body` - payload for the jetton wallet, which defines what should be done

### NFTs

#### Transfer NFT

Transfer the `NFTitem` to a new owner `NEW_OWNER_WALLET`.

```js
await connector.sendTransaction({
  validUntil: Math.floor(Date.now() / 1000) + 360,
  messages: [
    {
      address: NFTitem,
      amount: toNano("0.05"),
      payload: body.toBoc().toString("base64")
    }
  ]
})
```

- `NFTitem` - Address - The address of NFT item smart contract which we want transfer to a new owner `NEW_OWNER_WALLET`.
- `balance` - Integer, amount of Toncoin for gas payments in nanotons.
- `body` - payload for the NFT contract

`body` typically should be done according the following way:

```js
    import { Address, beginCell, Cell, toNano} from '@ton/ton'

//  transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell)
//   forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;

    const body = beginCell()
        .storeUint(5fcc3d14, 32)                 // NFT transfer op code
        .storeUint(0, 64)                        // query_id:uint64
        .storeAddress(NEW_OWNER_WALLET)          // destination:MsgAddress
        .storeUint(0, 1)                         // custom_payload:(Maybe ^Cell)
        .storeCoins(toNano('0.000000001'))       // forward_amount:(VarUInteger 16)
        .storeAddress(Wallet_DST)                // response_destination:MsgAddress
        .storeUint(0,1)                          // forward_amount:(VarUInteger 16)
        .endCell();
```

`WALLET_DST` - Address - The address of the initial NFT owner for the receiving excess


#### Deploy NFT

#### Buy NFT


## TON Connect Python SDK

### Jettons

#### Jetton Transfer

#### Jetton Mint

#### Jetton Burn

### NFTs

#### NFT Transfer

#### NFT Sale (getgems)

#### NFT Buy (getgems)

