# Writing Test Examples

## Writing Tests for Func

This page demonstrates how to write test for FunC contracts created in with [Blueprint](https://github.com/ton-org/blueprint) ([Sandbox](https://github.com/ton-org/sandbox)).
Test suites built for demo contract [fireworks](https://github.com/ton-community/fireworks-func). The fireworks is a smart contract which initially run via `set_first` message.

Once a new FunC project is created via `npm create ton@latest`, a test file `tests/contract.spec.ts` will be autogenerated in the project directory for testing the contract:

```typescript
import ...

describe('Fireworks', () => {
...


        expect(deployResult.transactions).toHaveTransaction({
...
        });

});

it('should deploy', async () => {
    // the check is done inside beforeEach
    // blockchain and fireworks are ready to use
});
```


Running tests using the following command:

```bash
npx blueprint test
```


### Transaction Success Test

This test checks if the fireworks are successfully set by sending a transaction with a value of 3.5 TON (converted to nanoTON) and the `op::set_first` (`0x5720cfeb`) op code. It then checks if the transaction was successful by validating the `from`, `to`, and `success` fields using the transaction matcher.

```typescript

    it('should set first fireworks', async () => {

        const launcher = await blockchain.treasury('launcher');

        const launchResult = await fireworks.sendDeployLaunch(launcher.getSender(), toNano('3.5'));


        expect(launchResult.transactions).toHaveTransaction({
            from: launcher.address,
            to: fireworks.address,
            op: 0x5720cfeb //set_first
        })

    });

```

This test checks if the fireworks are successfully launched by sending a transaction with a value of 3.5 TON (converted to nanoTON) and the `op::launch_first` (`0x6efe144b`) op code. It then checks if the transaction was successful by validating the `from`, `to`, and `success` fields using the transaction matcher.

```typescript
    it('should launch first fireworks', async () => {

        const launcher = await blockchain.treasury('launcher');

        const launchResult = await fireworks.sendDeployLaunch(launcher.getSender(), toNano('3.5'));

        expect(launchResult.transactions).toHaveTransaction({
            from: fireworks.address,
            op: 0x6efe144b //launch_first
        })

        printTransactionFees(launchResult.transactions);

    });

```


### Account Status Tests

This test checks if the contract is destroyed after launching the fireworks.

```typescript

    it('should destroy after launching', async () => {

        const launcher = await blockchain.treasury('launcher');

        const launchResult = await fireworks.sendDeployLaunch(
            launcher.getSender(),
            toNano('3.5'),
        );

        const init_code = code;
        const init_data = beginCell().storeUint(1, 32).endCell();


        const state_init = beginCell()
            .storeUint(0, 1) //no split_depth
            .storeUint(0, 1) // no special
            .storeUint(1, 1) // we have code
            .storeRef(init_code)
            .storeUint(1, 1) // we have data
            .storeRef(init_data)
            .storeUint(0, 1) // we have no library
            .endCell();

        const hash_dst = state_init.hash
        if (hash_dst === null) {
            throw Error("wrong type");
        }


        let launched_f1_address = new Address(0, hash_dst());


        expect(launchResult.transactions).toHaveTransaction({
            from: fireworks.address,
            to: launched_f1_address,
            success: true,
            endStatus: 'non-existing',
            destroyed: true
        });

    });

```

The full list of Account Status related fields:

* `destroyed` - `true` - if the existing contract was destroyed due to executing a certain transaction. Otherwise - `false`.
* `deploy` - Custom Sandbox flag that indicates whether the contract was deployed during this transaction. `true` if contract before this transaction was not initialized and after this transaction became initialized. Otherwise - `false`.
* `oldStatus` - AccountStatus before transaction execution. Values: `'uninitialized'`, `'frozen'`, `'active'`, `'non-existing'`.
* `endStatus` - AccountStatus after transaction execution. Values: `'uninitialized'`, `'frozen'`, `'active'`, `'non-existing'`.


### Operation Code Tests

This test shows how to check whether the operation code (op code) of incoming message is equal to the expected op code.

```typescript
   it('should be correct op code for the launching first fireworks', async () => {

        const launcher = await blockchain.treasury('launcher');

        const launchResult = await fireworks.sendDeployLaunch(
            launcher.getSender(),
            toNano('3.5'),
        );

        const init_code = code;
        const init_data = beginCell().storeUint(1, 32).endCell();


        const state_init = beginCell()
            .storeUint(0, 1) //no split_depth
            .storeUint(0, 1) // no special
            .storeUint(1, 1) // we have code
            .storeRef(init_code)
            .storeUint(1, 1) // we have data
            .storeRef(init_data)
            .storeUint(0, 1) // we have no library
            .endCell();

        const hash_dst = state_init.hash
        if (hash_dst === null) {
            throw Error("wrong type");
        }


        let launched_f1_address = new Address(0, hash_dst());


        expect(launchResult.transactions).toHaveTransaction({
            from: fireworks.address,
            to: launched_f1_address,
            success: true,
            op: 0x6efe144b, // 'launch_first' expected op code
            outMessagesCount: 4
        });

        expect(launchResult.transactions).toHaveTransaction({
            from: launched_f1_address,
            to: launcher.address,
            success: true,
            op: 0 // 0x00000000 - comment op code
        });

    });
```

> For Tact contracts, crc32 representation could be found in the project build directory, autogenerated with build contract.md file.
> Read more about [crc32](https://docs.ton.org/develop/data-formats/crc32) and op codes in the TON documentation.

### Message Counter Tests

This test checks if the correct number of messages are sent in the transaction.
For the first fireworks contract:

```typescript
     it('should be correct op code for the launching first fireworks', async () => {

        const launcher = await blockchain.treasury('launcher');

        const launchResult = await fireworks.sendDeployLaunch(
            launcher.getSender(),
            toNano('3.5'),
        );

        const init_code = code;
        const init_data = beginCell().storeUint(1, 32).endCell();


        const state_init = beginCell()
            .storeUint(0, 1) //no split_depth
            .storeUint(0, 1) // no special
            .storeUint(1, 1) // we have code
            .storeRef(init_code)
            .storeUint(1, 1) // we have data
            .storeRef(init_data)
            .storeUint(0, 1) // we have no library
            .endCell();

        const hash_dst = state_init.hash
        if (hash_dst === null) {
            throw Error("wrong type");
        }


        let launched_f1_address = new Address(0, hash_dst());


        expect(launchResult.transactions).toHaveTransaction({
            from: fireworks.address,
            to: launched_f1_address,
            success: true,
            op: 0x6efe144b, // 'launch_first' op code
            outMessagesCount: 4
        });

        expect(launchResult.transactions).toHaveTransaction({
            from: launched_f1_address,
            to: launcher.address,
            success: true,
            op: 0 // 0x00000000 - comment op code
        });

    });   it('fireworks contract should send msgs with comments in first fireworks', async() => {

        const launcher = await blockchain.treasury('launcher');

        const launchResult = await fireworks.sendDeployLaunch(
            launcher.getSender(),
            toNano('3.5'),
        );

        const init_code = code;
        const init_data = beginCell().storeUint(1, 32).endCell();


        const state_init = beginCell()
            .storeUint(0, 1) //no split_depth
            .storeUint(0, 1) // no special
            .storeUint(1, 1) // we have code
            .storeRef(init_code)
            .storeUint(1, 1) // we have data
            .storeRef(init_data)
            .storeUint(0, 1) // we have no library
            .endCell();

        const hash_dst = state_init.hash
        if (hash_dst === null) {
            throw Error("wrong type");
        }


        let launched_f1_address = new Address(0, hash_dst());



        expect(launchResult.transactions).toHaveTransaction({
            from: launched_f1_address,
            to: launcher.address,
            success: true,
            body: beginCell().storeUint(0,32).storeStringTail("send mode = 0").endCell() // 0x00000000 comment opcode and encoded comment

        });

        expect(launchResult.transactions).toHaveTransaction({
            from: launched_f1_address,
            to: launcher.address,
            success: true,
            body: beginCell().storeUint(0,32).storeStringTail("send mode = 1").endCell()
        });

        expect(launchResult.transactions).toHaveTransaction({
            from: launched_f1_address,
            to: launcher.address,
            success: true,
            body: beginCell().storeUint(0,32).storeStringTail("send mode = 2").endCell()
        });

        expect(launchResult.transactions).toHaveTransaction({
            from: launched_f1_address,
            to: launcher.address,
            success: true,
            body: beginCell().storeUint(0,32).storeStringTail("send mode = 32 + 128").endCell()
        });
    })

```

For the second fireworks contract:

```typescript
    it('should be correct op code for the launching second fireworks', async () => {

        const launcher = await blockchain.treasury('launcher');

        const launchResult = await fireworks.sendDeployLaunch(
            launcher.getSender(),
            toNano('3.5'),
        );

        const init_code = code;
        const init_data = beginCell().storeUint(2, 32).endCell();


        const state_init = beginCell()
            .storeUint(0, 1) //no split_depth
            .storeUint(0, 1) // no special
            .storeUint(1, 1) // we have code
            .storeRef(init_code)
            .storeUint(1, 1) // we have data
            .storeRef(init_data)
            .storeUint(0, 1) // we have no library
            .endCell();

        const hash_dst = state_init.hash
        if (hash_dst === null) {
            throw Error("wrong type");
        }


        let launched_f2_address = new Address(0, hash_dst());


        expect(launchResult.transactions).toHaveTransaction({
            from: fireworks.address,
            to: launched_f2_address,
            success: true,
            op: 0xa2e2c2dc, // 'launch_second' op code,
            outMessagesCount: 1
        });

        expect(launchResult.transactions).toHaveTransaction({
            from: launched_f2_address,
            to: launcher.address,
            success: true,
            op: 0 // 0x00000000 - comment op code
        });

    });
```


### Multi Transaction and Payload Tests

This test checks if the fireworks contract sends multiple messages with comments correctly. The body field contains a Cell that is built with @ton/core primitives.
#### For the first fireworks contract:

```typescript
   it('fireworks contract should send msgs with comments in first fireworks', async() => {

        const launcher = await blockchain.treasury('launcher');

        const launchResult = await fireworks.sendDeployLaunch(
            launcher.getSender(),
            toNano('3.5'),
        );

        const init_code = code;
        const init_data = beginCell().storeUint(1, 32).endCell();


        const state_init = beginCell()
            .storeUint(0, 1) //no split_depth
            .storeUint(0, 1) // no special
            .storeUint(1, 1) // we have code
            .storeRef(init_code)
            .storeUint(1, 1) // we have data
            .storeRef(init_data)
            .storeUint(0, 1) // we have no library
            .endCell();

        const hash_dst = state_init.hash
        if (hash_dst === null) {
            throw Error("wrong type");
        }


        let launched_f1_address = new Address(0, hash_dst());



        expect(launchResult.transactions).toHaveTransaction({
            from: launched_f1_address,
            to: launcher.address,
            success: true,
            body: beginCell().storeUint(0,32).storeStringTail("send mode = 0").endCell() // 0x00000000 comment opcode and encoded comment

        });

        expect(launchResult.transactions).toHaveTransaction({
            from: launched_f1_address,
            to: launcher.address,
            success: true,
            body: beginCell().storeUint(0,32).storeStringTail("send mode = 1").endCell()
        });

        expect(launchResult.transactions).toHaveTransaction({
            from: launched_f1_address,
            to: launcher.address,
            success: true,
            body: beginCell().storeUint(0,32).storeStringTail("send mode = 2").endCell()
        });

        expect(launchResult.transactions).toHaveTransaction({
            from: launched_f1_address,
            to: launcher.address,
            success: true,
            body: beginCell().storeUint(0,32).storeStringTail("send mode = 32 + 128").endCell()
        });
    })

```

#### For the second fireworks contract:

```typescript
   it('fireworks contract should send msgs with comments in second fireworks', async() => {

        const launcher = await blockchain.treasury('launcher');

        const launchResult = await fireworks.sendDeployLaunch(
            launcher.getSender(),
            toNano('3.5'),
        );

        const init_code = code;
        const init_data = beginCell().storeUint(2, 32).endCell();


        const state_init = beginCell()
            .storeUint(0, 1) //no split_depth
            .storeUint(0, 1) // no special
            .storeUint(1, 1) // we have code
            .storeRef(init_code)
            .storeUint(1, 1) // we have data
            .storeRef(init_data)
            .storeUint(0, 1) // we have no library
            .endCell();

        const hash_dst = state_init.hash
        if (hash_dst === null) {
            throw Error("wrong type");
        }


        let launched_f2_address = new Address(0, hash_dst());



        expect(launchResult.transactions).toHaveTransaction({
            from: launched_f2_address,
            to: launcher.address,
            success: true,
            body: beginCell().storeUint(0,32).storeStringTail("send_mode = 64").endCell() // 0x00000000 comment opcode and encoded comment

        });

    })


    it('should be executed and print fees', async() => {

        const launcher = await blockchain.treasury('launcher');

        const launchResult = await fireworks.sendDeployLaunch(
            launcher.getSender(),
            toNano('3.5'),
        );

        console.log(printTransactionFees(launchResult.transactions));

    });

```

### Printing and Reading Transaction Fees

During the test, reading the details about fees can be useful for optimizing the contract. The printTransactionFees function prints the entire transaction chain in a convenient manner."
```typescript

    it('should be executed and print fees', async() => {

        const launcher = await blockchain.treasury('launcher');

        const launchResult = await fireworks.sendDeployLaunch(
            launcher.getSender(),
            toNano('3.5'),
        );

        console.log(printTransactionFees(launchResult.transactions));

    });

```

For instance, in case of `launchResult` the following table will be printed:





| (index) |     op       |    valueIn     |    valueOut    |   totalFees    | outActions |
|---------|--------------|----------------|----------------|----------------|------------|
|    0    |    'N/A'     |     'N/A'      |   '3.5 TON'    | '0.010605 TON' |     1      |
|    1    | '0x5720cfeb' |   '3.5 TON'    | '2.186786 TON' | '0.015386 TON' |     2      |
|    2    | '0x6efe144b' | '1.093393 TON' | '1.081729 TON' | '0.008998 TON' |     4      |
|    3    | '0xa2e2c2dc' | '1.093393 TON' | '1.089269 TON' | '0.003458 TON' |     1      |
|    4    |    '0x0'     |  '0.099 TON'   |    '0 TON'     | '0.000309 TON' |     0      |
|    5    |    '0x0'     |   '0.1 TON'    |    '0 TON'     | '0.000309 TON' |     0      |
|    6    |    '0x0'     |  '0.099 TON'   |    '0 TON'     | '0.000309 TON' |     0      |
|    7    |    '0x0'     | '0.783729 TON' |    '0 TON'     | '0.000309 TON' |     0      |
|    8    |    '0x0'     | '1.089269 TON' |    '0 TON'     | '0.000309 TON' |     0      |



![](/img/docs/test-examples/fireworks_trace_tonviewer.png?=RAW)

index - is an ID of a transaction in the `launchResult` array.
* `0` - External request to the treasury (the Launcher) that resulted in a message `op::set_first` to Fireworks
* `1` - The Fireworks transaction that resulted in 4 messages to the Launcher
* `2` - Transaction on Launched Fireworks - 1 from the Launcher, message sent with `op::launch_first` op code.
* `2` - Transaction on Launched Fireworks - 2 from the Launcher, message sent with `op::launch_second` op code.
* `4` - Transaction on Launcher with incoming message from the Launched Fireworks - 1, message sent with `send mode = 0`
* `5` - Transaction on Launcher with incoming message from the Launched Fireworks - 1, message sent with `send mode = 1`
* `6` - Transaction on Launcher with incoming message from the Launched Fireworks - 1, message sent with `send mode = 2`
* `7` - Transaction on Launcher with incoming message from the Launched Fireworks - 1, message sent with `send mode = 128 + 32`
* `8` - Transaction on Launcher with incoming message from the Launched Fireworks - 2, message sent with `send mode = 64`


### Transaction Fees Tests

This test verifies whether the transaction fees for launching the fireworks are as expected. It is possible to define custom assertions for different parts of commission fees.

```typescript

  it('should be executed with expected fees', async() => {

        const launcher = await blockchain.treasury('launcher');

        const launchResult = await fireworks.sendDeployLaunch(
            launcher.getSender(),
            toNano('3.5'),
        );

        //totalFee
        console.log('total fees = ', launchResult.transactions[1].totalFees);

        const tx1 = launchResult.transactions[1];
        if (tx1.description.type !== 'generic') {
            throw new Error('Generic transaction expected');
        }

        //computeFee
        const computeFee = tx1.description.computePhase.type === 'vm' ? tx1.description.computePhase.gasFees : undefined;
        console.log('computeFee = ', computeFee);

        //actionFee
        const actionFee = tx1.description.actionPhase?.totalActionFees;
        console.log('actionFee = ', actionFee);


        if ((computeFee == null || undefined) ||
            (actionFee == null || undefined)) {
            throw new Error('undefined fees');
        }

        //The check, if Compute Phase and Action Phase fees exceed 1 TON
        expect(computeFee + actionFee).toBeLessThan(toNano('1'));


    });

```



