import ThemedImage from '@theme/ThemedImage';

# 证明验证（低级别）

## 概述
:::caution
本节描述了与TON进行低级交互的指令和手册。
假设您已经熟悉了[异构cell](/develop/data-formats/exotic-cells)、[TL-B 语言](/develop/data-formats/tl-b-language)并
理解了[简单证明验证](/develop/data-formats/exotic-cells#simple-proof-verifying-example)示例。
:::

本文描述了从Liteservers验证证明的高级示例。

从节点接收任何数据时，核实数据的真实性对于与区块链进行无信任交互非常重要。
然而，文章仅涵盖了与Liteserver无信任通信的一部分，
因为它假设您已经验证了从Liteserver（或其他任何人）收到的区块哈希。
区块哈希验证更为高级，因为您需要同步关键区块和（或）检查区块签名，
将来会在另一篇文章中描述。但无论如何，即使只使用这些示例，
您也降低了Liteserver发送错误数据而您相信的可能性。

## 区块头

假设我们知道一个区块ID：
```json
<TL BlockIdExt [wc=-1, shard=-9223372036854775808, seqno=31220993, root_hash=51ed3b9e728e7c548b15a5e5ce988b4a74984c3f8374f3f1a52c7b1f46c26406, file_hash=d4fcdc692de1a252deb379cd25774842b733e6a96525adf82b8ffc41da667bf5] >
```
我们向Liteserver请求此区块的头部。Liteserver的[响应](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tl/generate/scheme/lite_api.tl#L35)
包含一个`header_proof` boc。

<details>

  <summary><b>显示boc</b></summary>

```boc

b5ee9c72010207010001470009460351ed3b9e728e7c548b15a5e5ce988b4a74984c3f8374f3f1a52c7b1f46c26406001601241011ef55aaffffff110204050601a09bc7a98700000000040101dc65010000000100ffffffff000000000000000064b6c356000023d38ba64000000023d38ba64004886d00960007028101dc64fd01dc42bec400000003000000000000002e030098000023d38b96fdc401dc650048a3971c46472b85c8d761060a6e7ae9f13a90cdda815915a89597cfecb393a6b568807adfb3c1c5efc920907225175db61ca384e4f8b313799e3cbb8b7b4085284801018c6053c1185700c0fe4311d5cf8fa533ea0382e361a7b76d0cf299b75ac0356c000328480101741100d622b0d5264bcdb86a14e36fc8c349b82ae49e037002eb07079ead8b060015284801015720b6aefcbf406209522895faa6c0d10cc3315d90bcaf09791b19f595e86f8f0007

```
</details>

解序列化boc后，我们得到Cell：

```json
280[0351ED3B9E728E7C548B15A5E5CE988B4A74984C3F8374F3F1A52C7B1F46C264060016] -> {
	64[11EF55AAFFFFFF11] -> {
		640[9BC7A98700000000040101DC650100000

00100FFFFFFFF000000000000000064B6C356000023D38BA64000000023D38BA64004886D00960007028101DC64FD01DC42BEC400000003000000000000002E] -> {
			608[000023D38B96FDC401DC650048A3971C46472B85C8D761060A6E7AE9F13A90CDDA815915A89597CFECB393A6B568807ADFB3C1C5EFC920907225175DB61CA384E4F8B313799E3CBB8B7B4085]
		},
		288[01018C6053C1185700C0FE4311D5CF8FA533EA0382E361A7B76D0CF299B75AC0356C0003],
		288[0101741100D622B0D5264BCDB86A14E36FC8C349B82AE49E037002EB07079EAD8B060015],
		288[01015720B6AEFCBF406209522895FAA6C0D10CC3315D90BCAF09791B19F595E86F8F0007]
	}
}
```
我们应根据区块[Tlb 方案](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L442)进行反序列化：

```python
{
  'global_id': -239,
  'info':
    {
      'version': 0,
      'not_master': 0,
      'after_merge': 0,
      'before_split': 0,
      'after_split': 0,
      'want_split': False,
      'want_merge': True,
      'key_block': False,
      'vert_seqno_incr': 0,
      'flags': 1,
      'seqno': 31220993,
      'vert_seqno': 1,
      'shard': {'shard_pfx_bits': 0, 'workchain_id': -1, 'shard_prefix': 0},
      'gen_utime': 1689699158,
      'start_lt': 39391488000000,
      'end_lt': 39391488000004,
      'gen_validator_list_hash_short': 2288844950,
      'gen_catchain_seqno': 459393,
      'min_ref_mc_seqno': 31220989,
      'prev_key_block_seqno': 31212222,
      'gen_software': {'version': 3, 'capabilities': 46},
      'master_ref': None,
      'prev_ref': {'type_': 'prev_blk_info', 'prev': {'end_lt': 39391487000004, 'seqno': 31220992, 'root_hash': b'H\xa3\x97\x1cFG+\x85\xc8\xd7a\x06\nnz\xe9\xf1:\x90\xcd\xda\x81Y\x15\xa8\x95\x97\xcf\xec\xb3\x93\xa6', 'file_hash': b'\xb5h\x80z\xdf\xb3\xc1\xc5\xef\xc9 \x90r%\x17]\xb6\x1c\xa3\x84\xe4\xf8\xb3\x13y\x9e<\xbb\x8b{@\x85'}},
      'prev_vert_ref': None
    },
  'value_flow': None,
  'state_update': None,
  'extra': None
}
```

现在，我们应该检查反序列化区块中的`seqno`是否与我们所知的区块`seqno`匹配，然后计算唯一的
Merkle Proof引用的hash_1，并将其与我们所知的区块哈希进行比较：
```python
assert h_proof.refs[0].get_hash(0) == block_id.root_hash
```
现在，我们可以信任该Cell包含的所有其他数据

_检查证明示例：_ [Python](https://github.com/yungwine/pytoniq-core/blob/873a96aa2256db33b8f35fbe2ab8fe8cf8ae49c7/pytoniq_core/proof/check_proof.py#L19), [Kotlin](https://github.com/andreypfau/ton-kotlin/blob/b1edc4b134e89ccf252149f27c85fd530377cebe/ton-kotlin-lite

client/src/commonMain/kotlin/CheckProofUtils.kt#L15), [C++](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/check-proof.cpp#L34)

## 完整区块

对于`liteserver.getBlock`方法，证明验证与上述相同，但它包含完整的Cells，而不是修剪过的分支，用于[价值流](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L464)、[状态更新](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L412-L413)和[区块额外信息](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L452)的方案。

## 分片区块

分片证明是指分片引用实际存储在我们提供给Liteserver的主链区块中的证明。当我们调用`liteServer.getShardInfo`、`liteServer.getAccountState`和`liteServer.runSmcMethod`方法时，我们需要检查这些证明。

让我们向Liteserver请求上面提到的主链区块的分片信息：
```python
await client.raw_get_shard_info(master, wc=0)
```

Liteserver响应包含了分片区块的BlockIdExt：
```json
<TL BlockIdExt [wc=0, shard=-9223372036854775808, seqno=36908135, root_hash=39e5cbca5bf69750b5d9897872c3a0d7a3e614e521c53e4de728fafed38dce27, file_hash=f1f0e5cdc4b8a12cf2438dcab60f4712d1dc04f3792b1d72f2500cbf640948b7] >
```
分片证明boc：

<details>

  <summary><b>显示boc</b></summary>

```boc

... [省略boc内容以节省空间] ...

```
</details>

以及我们可以使用的`shard_descr` boc，如果我们信任Liteserver。

<details>

  <summary><b>显示boc</b></summary>

```boc

... [省略boc内容以节省空间] ...

```
</details>

分片证明boc反序列化后我们得到2个根：
```json
[<Cell 280[0351ED3B9E728E7C548B15A5E5CE988B4A74984C3F8374F3F1A52C7B1F46C264060016] -> 1 refs>, <Cell 280[0332BF3592969931CA4FBC7715494B50597F1884C0D847456029D8CF0E526E6046016F] -> 1 refs>]
```

第一个是主链区块的Merkle证明，我们应该检查（使用`check_block_header`函数）：
```json
... [省略Cell内容以节省空间] ...
```

Cell
```json
... [省略Cell内容以节省空间] ...
```

是[ShardState](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L412-L413) TLB方案的Merkle更新，所以我们需要记住新的哈希。

在我们确认唯一的Merkle证明Cell引用的Hash_1与我们所知的区块哈希匹配，并记住了新的ShardState哈希后，我们检查第二个`shard proof` Cell：

```json
... [省略Cell内容以节省空间] ...
```

正如我们所见，唯一的Merkle证明引用前缀为`9023AFE2`，这是[ShardStateUnsplit](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L410)
TLB方案的前缀，所以我们需要将这个引用的Hash_1与上一步中记住的进行比较：

```python
"""
这里mc_block_cell是第一个分片证明根，mc_state_root是第二个。
check_block_header_proof函数返回ShardState Merkle更新的新哈希。
"""

mc_state_hash = mc_state_root[0].get_hash(0)
state_hash = check_block_header_proof(mc_block_cell[0], blk.root_hash, True)

if mc_state_hash != state_hash:
    raise ProofError('mc state hashes mismatch')
```

* _为什么？_ - 因为我们已经检查了区块头证明，这意味着我们可以信任其他Cell数据。所以现在我们信任ShardState Merkle更新的新哈希，要信任第二个Cell数据，我们需要检查哈希是否匹配。

现在，让我们反序列化第二个Cell：

```python
{
    'global_id': -239,
    'shard_id': {'shard_pfx_bits': 0, 'workchain_id': -1, 'shard_prefix': 0},
    'seq_no': 31220993,
    'vert_seq_no': 1,
    'gen_utime': 1689699158,
    'gen_lt': 39391488000004,
    'min_ref_mc_seqno': 31220989,
    'out_msg_queue_info': <Cell 288[0101AFFE84CDD73951BCE07EEAAD120D00400295220D6F66F1163B5FA8668202D72B0001] -> 0 refs>,
    'before_split': 0,
    'accounts': <Cell 288[0101FAED0DD3CA110ADA3D22980E3795D2BDF15450E9159892BBF330CDFD13A3B880016E] -> 0 refs>,
    'overload_history': 0,
    'underload_history': 18446744073709551615,
    'total_balance': {'grams': 2364000148715550620, 'other': None},
    'total_validator_fees': {'grams': 0, 'other': None},
    'libraries': None,
    'master_ref': None,
    'custom': {
        'shard_hashes': {
            0: {'list': [{
                    'seq_no': 36908135,
                    'reg_mc_seqno': 31220993,
                    'start_lt': 39391487000000,
                    'end_lt': 39391487000005,
                    'root_hash': b"9\xe5\xcb\xca[\xf6\x97P\xb5\xd9\x89xr\xc3\xa0\xd7\xa3\xe6\x14\xe5!\xc5>M\xe7(\xfa\xfe\xd3\x8d\xce'",
                    'file_hash': b'\xf1\xf0\xe5\xcd\xc4\xb8\xa1,\xf2C\x8d\xca\xb6\x0fG\x12\xd1\xdc\x04\xf3y+\x1dr\xf2P\x0c\xbfd\tH\xb7',
                    'before_split': False,
                    'before_merge': False,
                    'want_split': False,
                    'want_merge': True,
                    'nx_cc_updated': False,
                    'flags': 0,
                    'next_catchain_seqno': 459607,
                    'next_validator_shard': 9223372036854775808,
                    'min_ref_mc_seqno': 31220989,
                    'gen_utime': 1689699153,
                    'split_merge_at': None,
                    'fees_collected': {'grams': 1016817575, 'other': None}, 'funds_created': {'grams': 1000000000, 'other': None}
                }]
            }
        },
        'config': {'config_addr': '5555555555555555555555555555555555555555555555555555555555555555', 'config': None},
        'flags': 1,
        'validator_info': {'validator_list_hash_short': 2862618141, 'catchain_seqno': 459393, 'nx_cc_updated': False},
        'prev_blocks': None,
        'after_key_block': True,
        'last_key_block': {'end_lt': 39382372000004, 'seqno': 31212222, 'root_hash': b'\xe2\x0c0\x8crt\x11\x8d\x05\xd0\xf7\x87BU\xfeZH\xddr\xf4\x12,\x9e\xac\xaf\xf2\xdf4J]\xee+', 'file_hash': b'\x01\xfc\xa6\x13PG\xee~x\x98\x7f\x15n~\xb5\x0bw\xe4\t\x7f\xa4\\\xd1\xa6\xda\x1d\xf5c\x03\x1c\xf6\x85'},
        'block_create_stats': {'type_': 'block_create_stats', 'counters': None},
        'global_balance': {'grams': 5089971531496870767, 'other': None

}
    }
}
```

由于我们信任这个Cell，我们可以信任分片区块数据（`ShardStateUnsplit` -> `custom` -> `shard_hashes` -> `0 (shrdblk wc)` -> `leaf`）。

_检查证明示例：_ [Python](https://github.com/yungwine/pytoniq/blob/master/pytoniq/proof/check_proof.py#L43), [C++](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/check-proof.cpp#L104)

## 账户状态

让我们证明账户`EQBvW8Z5huBkMJYdnfAEM5JqTNkuWX3diqYENkWsIL0XggGG`在文章开头我们开始时使用的同一个主链区块的状态。

Liteserver的[响应](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tl/generate/scheme/lite_api.tl#L37)包含主链区块id（必须与我们发送给ls的相同）、分片区块id、我们应该按照上述描述检查的`shard_proof` boc、`proof` boc和`state` boc。

<details>

  <summary><b>显示bocs</b></summary>

```boc
Proof boc:
    ... [省略boc内容以节省空间] ...
State boc:
    ... [省略boc内容以节省空间] ...
```
</details>

当我们检查了`Shard Proof`后，我们需要反序列化`proof`和`state` cells。首先，`proof`证明Cell必须有两个根：

```json
[<Cell 280[0339E5CBCA5BF69750B5D9897872C3A0D7A3E614E521C53E4DE728FAFED38DCE27001D] -> 1 refs>, <Cell 280[03F93FE5EDA41A6CE9ECB353FD589842BD3F5D5E73B846CB898525293FC742FD690219] -> 1 refs>]
```

第一个根是分片区块的Merkle证明（我们已经证明并信任它的哈希）：

```json
... [省略Cell内容以节省空间] ...
```

如同在`Shard Proof`验证中所做的，我们需要使用`check_block_header`函数：检查Block Cell是否有效并记住新的`StateUpdate`哈希。

然后我们反序列化第二个根（我们称之为`state_cell`）并检查它的Hash_1是否与我们记住的哈希匹配：
```python
proof_cells = Cell.from_boc(proof)
if len(proof_cells) != 2:
    raise ProofError('expected 2 root cells in account state proof')

state_cell = proof_cells[1]

state_hash = check_block_header_proof(proof_cells[0][0], shrd_blk.root_hash, True)

if state_cell[0].get_hash(0) != state_hash:
    raise ProofError('state hashes mismatch')
```

现在我们可以信任`state_cell`，它看起来是这样的：

<details>

  <summary><b>显示Cell</b></summary>

```json
... [省略Cell内容以节省空间] ...
```

</details>

同样，唯一的Merkle证明引用前缀为`9023AFE2`，这是[ShardStateUnsplit](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L410)
TLB方案的前缀，所以我们要根据TLB方案进行反序列化：

```python
{
    'global_id': -239,
    'shard_id': {'shard_pfx_bits': 0, 'workchain_id': 0, 'shard_prefix': 0},
    'seq_no': 36908135,
    'vert_seq_no': 1,
    'gen_utime': 1689699153,
    'gen_lt': 39391487000005,
    'min_ref_mc_seqno': 31220989,
    'out_msg_queue_info': <Cell 288[010138F8D1C6E9F798A477D13AA26CB4D6CFE1A17949AC276B2F1E0CE037A521B9BC0001] -> 0 refs>,
    'before_split': 0,
    'accounts': (
        {
            50368879097771769677871174881221998657607998794347754829932074327482686052226: {
                'account': None,
                'last_trans_hash': b'd\x9bF\xacr\xe6\xe4\xd4\xc1);f\xd5\x8d\x9e\xd7\xa5I\x02\xbe\xef\xd9\x7f[\xffyw\xdd\x85\x99\x8b=',
                'last_trans_lt': 39330697000001,
                'cell': <Cell 320[649B46AC72E6E4D4C1293B66D58D9ED7A54902BEEFD97F5BFF7977DD85998B3D000023C564393441] -> 1 refs>
            }
        },
        [
            {'split_depth': 0, 'balance': {'grams': 5873792469, 'other': None}},
            {'split_depth': 0, 'balance': {'grams': 5991493155, 'other': None}},
            {'split_depth': 0, 'balance': {'grams': 63109456003, 'other': None}},
            {'split_depth': 0, 'balance': {'grams': 63822897549, 'other': None}},
            ...
            {'split_depth': 0, 'balance': {'grams': 21778458402704, 'other': None}},
            {'split_depth': 0, 'balance': {'grams': 54074699968483, 'other': None}},
            {'split_depth': 0, 'balance': {'grams': 2725956214994157511, 'other': None}}
        ]
    ),
    'overload_history': 0,
    'underload_history': 18446744073709551615,
    'total_balance': {'grams': 2725956214994157511, 'other': None},
    'total_validator_fees': {'grams': 37646260890702444, 'other': None},
    'libraries': None,
    'master_ref': {'master': {'end_lt': 39391484000004, 'seqno': 31220989, 'root_hash': b'/\xa7\x8e\xc5)\xbc\xf9\x93\x1e\x14\xf9\xd8\xb2~\xc1F\x92\x90\xc0\xba\xef\x82V\xd6W\xceW;\x96y\xc5\x99

', 'file_hash': b't1\xfc\xdak\xf2\xd0\xbe94J\x936\xcf\xe0\xae\x9c\x84J\x88\xd2\xbd\x80"\x10.@\x12\xa7`\xd4\xdb'}},
    'custom': None
}
```

我们需要`account`字段，它具有[ShardAccounts](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L261)类型。
`ShardAccounts`是一个HashmapAugE，其中键是地址的hash_part，值具有`ShardAccount`类型，额外数据具有`DeepBalanceInfo`类型。

解析地址`EQBvW8Z5huBkMJYdnfAEM5JqTNkuWX3diqYENkWsIL0XggGG`，我们得到hash_part等于`50368879097771769677871174881221998657607998794347754829932074327482686052226`，因此我们需要
从Hashmap中获取这个键的值：

```python
{
    50368879097771769677871174881221998657607998794347754829932074327482686052226: {
        'account': None,
        'last_trans_hash': b'd\x9bF\xacr\xe6\xe4\xd4\xc1);f\xd5\x8d\x9e\xd7\xa5I\x02\xbe\xef\xd9\x7f[\xffyw\xdd\x85\x99\x8b=',
        'last_trans_lt': 39330697000001,
        'cell': <Cell 320[649B46AC72E6E4D4C1293B66D58D9ED7A54902BEEFD97F5BFF7977DD85998B3D000023C564393441] -> 1 refs>
    }
}
```

我们需要记住`last_trans_hash`和`last_trans_lt`，因为我们可以使用它们来获取账户交易，并检查这些数据的整个Cell：

```json
320[649B46AC72E6E4D4C1293B66D58D9ED7A54902BEEFD97F5BFF7977DD85998B3D000023C564393441] -> {
	288[01018282D13BF66B9ACE1FBF5D3ABD1C59CC46D61AF1D47AF1665D3013D8F9E474880008]
}
```

我们看到Cell是一个普通的Cell，级别为1，只有一个引用 - 被剪裁的账户数据，因此我们计算这个被剪裁分支的Hash_1 - 我们可以信任的账户状态哈希：`8282d13bf66b9ace1fbf5d3abd1c59cc46d61af1d47af1665d3013d8f9e47488`。

现在最后一步是反序列化`state` boc：

```json
449[C006F5BC67986E06430961D9DF00433926A4CD92E597DDD8AA6043645AC20BD178222C859043259E0D9000008F1590E4D10D405786BD755300] -> {
	... [省略其他Cell内容以节省空间] ...
}
```

计算其表示哈希，并确保它与我们从被剪裁的Cell中得到的匹配：`8282d13bf66b9ace1fbf5d3abd1c59cc46d61af1d47af1665d3013d8f9e47488`。

并根据[Account](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L231-L233) TLB方案进行反序列化：

```python
{
    'addr': Address<EQBvW8Z5huBkMJYdnfAEM5JqTNkuWX3diqYENkWsIL0XggGG>,
    'storage_stat': {'used': {'cells': 22, 'bits': 5697, 'public_cells': None}, 'last_paid': 1689502130, 'due_payment': None},
    'storage': {
        'last_trans_lt': 39330697000003,
        'balance': {'grams': 5873792469, 'other': None},
        'state': {
            'type_': 'account_active',
            'state

_init': {'split_depth': None, 'special': None, 'code': <Cell 80[FF00F4A413F4BCF2C80B] -> 1 refs>, 'data': <Cell 321[000000E929A9A317C1B3226CE226D6D818BAFE82D3633AA0F06A6C677272D1F9B760FF0D0DCF56D800] -> 0 refs>, 'library': None}
        }
    }
}
```

现在我们可以信任这个账户状态数据。

_检查证明示例：_ [Python](https://github.com/yungwine/pytoniq/blob/master/pytoniq/proof/check_proof.py#L87), [Kotlin](https://github.com/andreypfau/ton-kotlin/blob/b1edc4b134e89ccf252149f27c85fd530377cebe/ton-kotlin-liteclient/src/commonMain/kotlin/CheckProofUtils.kt#L37), [C++](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/check-proof.cpp#L161)
```

## 账户交易

对于 [liteServer.getTransactions](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tl/generate/scheme/lite_api.tl#L71) 请求，我们必须提供用于开始的交易的 `lt` 和 `hash`。
如果我们想获取最后的账户交易，我们可以从 `ShardAccount`（上文描述过）获取它们，并信任这些 `lt` 和 `hash`。

当我们从Liteserver接收到交易时，我们会得到一个包含我们所请求交易数量的boc根。每个根都是一个cell(Cell)，我们应该根据 [Transaction](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L263-L269) TLB方案进行反序列化。
对于第一个交易cell，我们应该检查其哈希是否与我们从账户状态获取的 `last_trans_hash` 匹配。然后我们记住 `prev_trans_hash` 字段的值，并将其与第二个根的哈希进行比较，依此类推。

## 区块交易

让我们向Liteserver询问属于我们在文章开头提到的区块的交易。
LiteServer 的[回应](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/lite_api.tl#L46)包含了包含交易的 `ids` 字段和 `proof` boc。首先，让我们反序列化 `proof`：

```json
280[0351ED3B9E728E7C548B15A5E5CE988B4A74984C3F8374F3F1A52C7B1F46C264060016] -> {
    ... // JSON 数据被省略以节省空间
}
```

现在我们应该检查区块头证明（以信任这个cell数据）并根据区块TLB方案进行反序列化：

```python
{
    ... // Python 数据被省略以节省空间
}
```

在这种情况下，我们应该记住字段 `block` -> `extra` -> `account_blocks`，它的类型是 [ShardAccountBlocks](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L282)，是HashmapAugE，其中键是地址的hash_part，值是 [AccountBlock](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L277-L280) 类型，额外的是 `CurrencyCollection` 类型：

```python
{
    ... // Python 数据被省略以节省空间
}
```

现在让我们检查 `ids`：

```python
[
    ... // Python 数据被省略以节省空间
]
```

对于这里的每个交易，我们需要在我们记住的 `account_block` 中找到它，并比较哈希：

```python
block_trs: dict = acc_block.get(int(tr['account'], 16)).transactions[0]
block_tr: Cell = block_trs.get(tr['lt'])
assert block_tr.get_hash(0) == tr['hash']
```

:::note

在这个例子中，检查 `ids` 字段是不必要的，我们可以直接从账户块中取交易。
但是当你请求 [liteServer.listBlockTransactionsExt](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/lite_api.tl#L80) 方法时，
你需要类似地检查证明，但在那种情况下，你确实需要比较哈希。

:::

## 配置

让我们向Liteserver请求1、4、5、7、8和15号[配置参数](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/lite_api.tl#L83)（对于 [liteServer.getConfigAll](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/lite_api.tl#L82) 方法，您可以获取所有参数，验证证明的方式是相同的）。
[回应](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/lite_api.tl#L53)包含 `state_proof` 和 `config_proof`。

首先，让我们反序列化 `state_proof` cell：

```json
280[0351ED3B9E728E7C548B15A5E5CE988B4A74984C3F8374F3F1A52C7B1F46C264060016] -> {
    ... // JSON 数据被省略以节省空间
}
```

对于此cell，我们应该检查区块头证明，并记住 `StateUpdate` 的新哈希值。

现在，让我们反序列化 `config_proof` cell：

<details>

  <summary><b>显示cell</b></summary>

```json
280[0332BF3592969931CA4FBC7715494B50597F1884C0D847456029D8CF0E526E6046016F] -> {
    ... // JSON 数据被省略以节省空间
}
```

</details>

我们需要将此 Merkle 证明的 Hash_1 仅与我们从上面的 `check_block_header` 函数获得的哈希进行比较，这样我们才能信任此cell：

```python
state_hash = check_block_header_proof(state_proof[0], block.root_hash, True)
if config_proof[0].get_hash(0) != state_hash:
    raise LiteClientError('hashes mismatch')
```

现在，让我们根据 `ShardStateUnsplit` 方案反序列化cell：

```python
{
    ... // Python 数据被省略以节省空间
}
```

并获取 `ShardStateUnsplit` -> `custom` -> `config` -> `config` 字段，这是一个哈希映射，其中键是配置参数编号，值是包含参数值的cell。

对所有参数反序列化后，我们得到：

```python
{
    1: {
        'elector_addr': b'33333333333333333333333333333333',
    },
    4: {
        'dns_root_addr': b'\xe5gT\xf84&\xf6\x9b\t&{\xd8v\xac\x97\xc4H!4[~&k\xd9V\xa7\xbf\xbf\xb9\x8d\xf3\\',
    },
    5: {
        'blackhole_addr': b'\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff',
        'fee_burn_nom': 1,
        'fee_burn_denom': 2
    },
    7: {
        'to_mint': {'dict': {239: 666666666666, 4294967279: 1000000000000}}
    },
    8: {
        'version': 2,
        'capabilities': 46
    },
    15: {
        'validators_elected_for': 65536,
        'elections_start_before': 32768,
        'elections_end_before': 8192,
        'stake_held_for': 32768
    }
}
```

## 参见

* [奇异cell](/develop/data-formats/exotic-cells)
